import{aQ as O,O as N,aR as T,aS as E,L as b,am as B,a8 as M,aT as W,j as S,aU as m,M as z,aL as X,at as G,N as Q,aV as Y,X as Z,an as q,u as J,aN as K,aW as x,aX as p,aY as A,aZ as k}from"./Di62MCsn.js";const ee={trailing:!0};function ae(e,a=25,i={}){if(i={...ee,...i},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let l,t,n=[],r,f;const o=(u,s)=>(r=te(e,u,s),r.finally(()=>{if(r=null,i.trailing&&f&&!t){const _=o(u,f);return f=null,_}}),r);return function(...u){return r?(i.trailing&&(f=u),r):new Promise(s=>{const _=!t&&i.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const v=i.leading?l:o(this,u);for(const y of n)y(v);n=[]},a),_?(l=o(this,u),s(l)):n.push(s)})}}async function te(e,a,i){return await e.apply(a,i)}function re(e){return Array.isArray(e)?e:[e]}const se=Symbol.for("nuxt:client-only"),g="<div></div>",V=new WeakMap;function de(e){if(V.has(e))return V.get(e);const a={...e};return a.render?a.render=(i,l,t,n,r,f)=>{var o;if(n.mounted$??i.mounted$){const u=(o=e.render)==null?void 0:o.bind(i)(i,l,t,n,r,f);return u.children===null||typeof u.children=="string"?O(u):N(u)}return T(i._.vnode.el,g)}:a.template&&(a.template=`
      <template v-if="mounted$">${e.template}</template>
      <template v-else>${g}</template>
    `),a.setup=(i,l)=>{var o;const t=E(),n=b(t.isHydrating===!1),r=B();if(t.isHydrating){const u={...r.attrs},s=ne(r);for(const _ in u)delete r.attrs[_];M(()=>{Object.assign(r.attrs,u),r.vnode.dirs=s})}M(()=>{n.value=!0});const f=((o=e.setup)==null?void 0:o.call(e,i,l))||{};return W(f)?Promise.resolve(f).then(u=>typeof u!="function"?(u||(u={}),u.mounted$=n,u):(...s)=>{if(n.value||!t.isHydrating){const _=u(...s);return _.children===null||typeof _.children=="string"?O(_):N(_)}return T(r==null?void 0:r.vnode.el,g)}):typeof f=="function"?(...u)=>{if(n.value){const s=f(...u);return s.children===null||typeof s.children=="string"?O(s,l.attrs):N(s,l.attrs)}return T(r==null?void 0:r.vnode.el,g)}:Object.assign(f,{mounted$:n})},V.set(e,a),a}function ne(e){if(!e||!e.vnode.dirs)return null;const a=e.vnode.dirs;return e.vnode.dirs=null,a}const ie=e=>e==="defer"||e===!1;function fe(...e){var y;const a=typeof e[e.length-1]=="string"?e.pop():void 0;ce(e[0],e[1])&&e.unshift(a);let[i,l,t={}]=e;const n=S(()=>G(i));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const r=E();t.server??(t.server=!0),t.default??(t.default=ue),t.getCachedData??(t.getCachedData=L),t.lazy??(t.lazy=!1),t.immediate??(t.immediate=!0),t.deep??(t.deep=m.deep),t.dedupe??(t.dedupe="cancel"),t._functionName,r._asyncData[n.value];const f={cause:"initial",dedupe:t.dedupe};(y=r._asyncData[n.value])!=null&&y._init||(f.cachedData=t.getCachedData(n.value,r,{cause:"initial"}),r._asyncData[n.value]=j(r,n.value,l,t,f.cachedData));const o=r._asyncData[n.value];o._deps++;const u=()=>r._asyncData[n.value].execute(f),s=t.server!==!1&&r.payload.serverRendered;{let c=function(D){const h=r._asyncData[D];h!=null&&h._deps&&(h._deps--,h._deps===0&&(h==null||h._off()))};const d=B();if(d&&s&&t.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const D=d._nuxtOnBeforeMountCbs;p(()=>{D.forEach(h=>{h()}),D.splice(0,D.length)}),A(()=>D.splice(0,D.length))}const C=d&&(d._nuxtClientOnly||k(se,!1));s&&r.isHydrating&&(o.error.value||o.data.value!=null)?(o.pending.value=!1,o.status.value=o.error.value?"error":"success"):d&&(!C&&r.payload.serverRendered&&r.isHydrating||t.lazy)&&t.immediate?d._nuxtOnBeforeMountCbs.push(u):t.immediate&&u();const U=K(),F=z([n,...t.watch||[]],([D],[h])=>{var R,H;if((D||h)&&D!==h){const I=((R=r._asyncData[h])==null?void 0:R.data.value)!==m.value;h&&c(h);const w={cause:"initial",dedupe:t.dedupe};(H=r._asyncData[D])!=null&&H._init||(w.cachedData=t.getCachedData(D,r,{cause:"initial"}),r._asyncData[D]=j(r,D,l,t,w.cachedData)),r._asyncData[D]._deps++,(t.immediate||I)&&r._asyncData[D].execute(w)}else o._execute({cause:"watch",dedupe:t.dedupe})},{flush:"sync"});U&&X(()=>{F(),c(n.value)})}const _={data:P(()=>{var c;return(c=r._asyncData[n.value])==null?void 0:c.data}),pending:P(()=>{var c;return(c=r._asyncData[n.value])==null?void 0:c.pending}),status:P(()=>{var c;return(c=r._asyncData[n.value])==null?void 0:c.status}),error:P(()=>{var c;return(c=r._asyncData[n.value])==null?void 0:c.error}),refresh:(...c)=>r._asyncData[n.value].execute(...c),execute:(...c)=>r._asyncData[n.value].execute(...c),clear:()=>$(r,n.value)},v=Promise.resolve(r._asyncDataPromises[n.value]).then(()=>_);return Object.assign(v,_),v}function P(e){return S({get(){var a;return(a=e())==null?void 0:a.value},set(a){const i=e();i&&(i.value=a)}})}function ce(e,a){return!(typeof e=="string"||typeof e=="object"&&e!==null||typeof e=="function"&&typeof a=="function")}async function ve(e){await new Promise(i=>x(i));const a=e?re(e):void 0;await E().hooks.callHookParallel("app:data:refresh",a)}function $(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=m.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=m.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}function le(e,a){const i={};for(const l of a)i[l]=e[l];return i}function j(e,a,i,l,t){var _;(_=e.payload._errors)[a]??(_[a]=m.errorValue);const n=l.getCachedData!==L,r=i,f=l.deep?Q:b,o=t!=null,u=e.hook("app:data:refresh",async v=>{(!v||v.includes(a))&&await s.execute({cause:"refresh:hook"})}),s={data:f(o?t:l.default()),pending:b(!o),error:Y(e.payload._errors,a),status:b("idle"),execute:(v={})=>{if(e._asyncDataPromises[a]){if(ie(v.dedupe??l.dedupe))return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if(v.cause==="initial"||e.isHydrating){const c="cachedData"in v?v.cachedData:l.getCachedData(a,e,{cause:v.cause??"refresh:manual"});if(c!=null)return e.payload.data[a]=s.data.value=c,s.error.value=m.errorValue,s.status.value="success",Promise.resolve(c)}s.pending.value=!0,s.status.value="pending";const y=new Promise((c,d)=>{try{c(r(e))}catch(C){d(C)}}).then(async c=>{if(y.cancelled)return e._asyncDataPromises[a];let d=c;l.transform&&(d=await l.transform(c)),l.pick&&(d=le(d,l.pick)),e.payload.data[a]=d,s.data.value=d,s.error.value=m.errorValue,s.status.value="success"}).catch(c=>{if(y.cancelled)return e._asyncDataPromises[a];s.error.value=q(c),s.data.value=J(l.default()),s.status.value="error"}).finally(()=>{y.cancelled||(s.pending.value=!1,delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=y,e._asyncDataPromises[a]},_execute:ae((...v)=>s.execute(...v),0,{leading:!0}),_default:l.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{var v;u(),(v=e._asyncData[a])!=null&&v._init&&(e._asyncData[a]._init=!1),n||Z(()=>{var y;(y=e._asyncData[a])!=null&&y._init||($(e,a),s.execute=()=>Promise.resolve(),s.data.value=m.value)})}};return s}const ue=()=>m.value,L=(e,a,i)=>{if(a.isHydrating)return a.payload.data[e];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return a.static.data[e]};export{de as c,ve as r,fe as u};
